# [素数统计](https://leetcode.com/problems/count-primes/)
## Problem
- 给定一个正整数n，请找出0～n之间的所有素数
- 备注
  - 素数：只能被1和它自身整除
## Solution
### 基础方法
- 整体思路：循环遍历0～n之间的每一个数，判断是否是素数
- 判断是否是素数
  - 遍历0～sqrt(n)之间的数，判断n是否能够被它整除
```
12 = 1*12
12 = 2*6
12 = 3*4
12 = sqrt(12) * sqrt(12)
12 = 4*3
12 = 6*2
12 = 12*1
```
从上述可以看，n的因子是关于sqrt(n)对称，所以如果在0～sqrt(n)之中没有因子，那么我们可以认为这个数就是一个素数

### 标记法
![mark_status](https://leetcode.com/static/images/solutions/Sieve_of_Eratosthenes_animation.gif)
- 第1步：如果n小于等于1，直接返回0
- 第2步：创建一个大小为n的标记数组
  - 用于标记每个数字是否是素数
    - 1：是素数
    - 0：不是素数
  - 全部填充为1，默认全部是素数
- 第3步：修改标记数组前两位为0，因为0和1不是素数
- 第4步：遍历0～n
  - 第4.1步：如果第i个数是素数：
    - 遍历i～n：
    - 标记每个能够被i整除的数为0

### 标记法优化
- 与基础法同理，在第四步的时候，不需要全部遍历，只要遍历到sqrt(n)即可
- 在4.1步中，可以从i*i开始遍历

## 总结
- 基础法与标记法是互逆的
  - 基础法是从被除数考虑是否有因子
  - 标记法是从因子出发，剔除每一个被除数，避免重复运算
